---
const bubbles = Array.from({ length: 25 }, (_, i) => ({
  id: i + 1,
  size: `${Math.random() * 30 + 10}px`,
  left: `${Math.random() * 95}%`,
  delay: `${Math.random() * 8}s`, // Positive delays only
  duration: `${Math.random() * 10 + 8}s`, // Slightly faster animations
}))

const instanceId = Math.random().toString(36).substring(2, 9)
---

<style>
  .bubble {
    @apply absolute rounded-full bg-radial-[at_50%_75%] from-[transparent] via-[#bedbff6f] to-[transparent] to-90%;
    bottom: -10px; /* Start slightly below the container */
    will-change: transform, opacity;
    opacity: 0; /* Start transparent */
    border: 1px solid #e4e4e4;
    contain: strict;
  }

  .tickets-button {
    background-size: 200% 100%;
    animation: shimmer 3s linear infinite;
    position: relative;
    overflow: hidden;
  }

  .tickets-button::before {
    content: "";
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.3), transparent);
    transform: rotate(30deg);
    animation: shine 3s linear infinite;
  }

  @keyframes shimmer {
    100% {
      background-position: 200% 0;
    }
  }

  @keyframes shine {
    0% {
      transform: translateX(-100%) rotate(30deg);
    }
    100% {
      transform: translateX(100%) rotate(50deg);
    }
  }
</style>

<div class="ocean pointer-events-none absolute inset-0 h-full overflow-hidden" data-id={instanceId}>
  {
    bubbles.map((bubble) => (
      <div
        class="bubble tickets-button"
        style={`
        width: ${bubble.size};
        height: ${bubble.size};
        left: ${bubble.left};
        animation-duration: ${bubble.duration};
        animation-delay: ${bubble.delay};
      `}
      />
    ))
  }
</div>

<script>
  if (typeof document !== "undefined") {
    // Store style elements to avoid creating new ones on resize
    const styleCache = new Map()

    // Use requestAnimationFrame for better performance
    const initBubbles = () => {
      // Use requestAnimationFrame to sync with browser rendering cycle
      requestAnimationFrame(() => {
        const oceanContainers = document.querySelectorAll(".ocean")

        oceanContainers.forEach((ocean) => {
          if (!(ocean instanceof HTMLElement)) return

          const instanceId = ocean.getAttribute("data-id")
          if (!instanceId) return

          const oceanHeight = ocean.offsetHeight

          // Check if we already have a style element for this instance
          let style = styleCache.get(instanceId)

          // Create style element only if it doesn't exist yet
          if (!style) {
            style = document.createElement("style")
            document.head.appendChild(style)
            styleCache.set(instanceId, style)
          }

          // Update animation keyframes with current height
          style.textContent = `
            .ocean[data-id="${instanceId}"] .bubble {
              animation-name: bubble-${instanceId};
              will-change: transform, opacity;
            }

            @keyframes bubble-${instanceId} {
              0% {
                transform: translate3d(0, 0, 0);
                opacity: 0;
              }
              10% {
                opacity: 0.7;
              }
              90% {
                opacity: 0.5;
              }
              100% {
                transform: translate3d(0, -${oceanHeight + 20}px, 0);
                opacity: 0;
              }
            }
          `
        })
      })
    }

    // Debounce resize events to prevent excessive calculations
    let resizeTimer: number | undefined
    const handleResize = () => {
      if (resizeTimer) clearTimeout(resizeTimer)
      resizeTimer = setTimeout(initBubbles, 200) as unknown as number
    }

    // Initialize on load
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", initBubbles)
    } else {
      initBubbles()
    }

    // Use passive event listener for better scroll performance
    window.addEventListener("resize", handleResize, { passive: true })
  }
</script>
